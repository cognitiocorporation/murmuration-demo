{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/createClass\");\n\nvar csv = require('async-csv');\n\nvar fs = require('fs');\n/**\n * Converts an array of objects into a CSV file.\n */\n\n\nvar ObjectsToCsv = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of the object array to csv converter.\n   * @param {object[]} objectArray\n   */\n  function ObjectsToCsv(objectArray) {\n    _classCallCheck(this, ObjectsToCsv);\n\n    if (!Array.isArray(objectArray)) {\n      throw new Error('The input to objects-to-csv must be an array of objects.');\n    }\n\n    if (objectArray.length > 0) {\n      if (objectArray.some(function (row) {\n        return typeof row !== 'object';\n      })) {\n        throw new Error('The array must contain objects, not other data types.');\n      }\n    }\n\n    this.data = objectArray;\n  }\n  /**\n   * Saves the CSV file to the specified file.\n   * @param {string} filename - The path and filename of the new CSV file.\n   * @param {object} options - The options for writing to disk.\n   * @param {boolean} [options.append] - Whether to append to file. Default is overwrite (false).\n   * @param {boolean} [options.bom] - Append the BOM mark so that Excel shows\n   * @param {boolean} [options.allColumns] - Whether to check all items for column names or only the first.  Default is the first.\n   * Unicode correctly.\n   */\n\n\n  _createClass(ObjectsToCsv, [{\n    key: \"toDisk\",\n    value: function () {\n      var _toDisk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(filename, options) {\n        var addHeader, fileNotExists, allColumns, data;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (filename) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('Empty filename when trying to write to disk.');\n\n              case 2:\n                addHeader = false; // If the file didn't exist yet or is empty, add the column headers\n                // as the first line of the file. Do not add it when we are appending\n                // to an existing file.\n\n                fileNotExists = !fs.existsSync(filename) || fs.statSync(filename).size === 0;\n\n                if (fileNotExists || !options || !options.append) {\n                  addHeader = true;\n                }\n\n                allColumns = options && options.allColumns ? options.allColumns : false;\n                _context.next = 8;\n                return this.toString(addHeader, allColumns);\n\n              case 8:\n                data = _context.sent;\n\n                // Append the BOM mark if requested at the beginning of the file, otherwise\n                // Excel won't show Unicode correctly. The actual BOM mark will be EF BB BF,\n                // see https://stackoverflow.com/a/27975629/6269864 for details.\n                if (options && options.bom && fileNotExists) {\n                  data = \"\\uFEFF\" + data;\n                }\n\n                if (!(options && options.append)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  fs.appendFile(filename, data, 'utf8', function (error) {\n                    if (error) {\n                      reject(error);\n                    } else {\n                      resolve(data);\n                    }\n                  });\n                }));\n\n              case 14:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  fs.writeFile(filename, data, 'utf8', function (error) {\n                    if (error) {\n                      reject(error);\n                    } else {\n                      resolve(data);\n                    }\n                  });\n                }));\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function toDisk(_x, _x2) {\n        return _toDisk.apply(this, arguments);\n      }\n\n      return toDisk;\n    }()\n    /**\n     * Returns the CSV file as string.\n     * @param {boolean} header - If false, omit the first row containing the\n     * column names.\n     * @param {boolean} allColumns - Whether to check all items for column names.\n     *   Uses only the first item if false.\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function () {\n      var _toString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var header,\n            allColumns,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                header = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : true;\n                allColumns = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;\n                _context2.next = 4;\n                return convert(this.data, header, allColumns);\n\n              case 4:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function toString() {\n        return _toString.apply(this, arguments);\n      }\n\n      return toString;\n    }()\n  }]);\n\n  return ObjectsToCsv;\n}();\n/**\n * Private method to run the actual conversion of array of objects to CSV data.\n * @param {object[]} data\n * @param {boolean} header - Whether the first line should contain column headers.\n * @param {boolean} allColumns - Whether to check all items for column names.\n *   Uses only the first item if false.\n * @returns {string}\n */\n\n\nfunction convert(_x3) {\n  return _convert.apply(this, arguments);\n}\n\nfunction _convert() {\n  _convert = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(data) {\n    var header,\n        allColumns,\n        columnNames,\n        csvInput,\n        _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            header = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : true;\n            allColumns = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : false;\n\n            if (!(data.length === 0)) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", '');\n\n          case 4:\n            columnNames = allColumns ? _toConsumableArray(data.reduce(function (columns, row) {\n              // check each object to compile a full list of column names\n              Object.keys(row).map(function (rowKey) {\n                return columns.add(rowKey);\n              });\n              return columns;\n            }, new Set())) : Object.keys(data[0]); // just figure out columns from the first item in array\n\n            if (allColumns) {\n              columnNames.sort(); // for predictable order of columns\n            } // This will hold data in the format that `async-csv` can accept, i.e.\n            // an array of arrays.\n\n\n            csvInput = [];\n\n            if (header) {\n              csvInput.push(columnNames);\n            } // Add all other rows:\n\n\n            csvInput.push.apply(csvInput, _toConsumableArray(data.map(function (row) {\n              return columnNames.map(function (column) {\n                return row[column];\n              });\n            })));\n            _context3.next = 11;\n            return csv.stringify(csvInput);\n\n          case 11:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _convert.apply(this, arguments);\n}\n\nmodule.exports = ObjectsToCsv;","map":{"version":3,"sources":["/Users/angelvazquez/Dropbox/My Mac (Angels-MacBook-Pro-4.local)/Documents/Projects/Murmuration - 10:04:2021/node_modules/objects-to-csv/index.js"],"names":["csv","require","fs","ObjectsToCsv","objectArray","Array","isArray","Error","length","some","row","data","filename","options","addHeader","fileNotExists","existsSync","statSync","size","append","allColumns","toString","bom","Promise","resolve","reject","appendFile","error","writeFile","header","convert","columnNames","reduce","columns","Object","keys","map","rowKey","add","Set","sort","csvInput","push","column","stringify","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst csv = require('async-csv');\nconst fs = require('fs');\n\n/**\n * Converts an array of objects into a CSV file.\n */\nclass ObjectsToCsv {\n  /**\n   * Creates a new instance of the object array to csv converter.\n   * @param {object[]} objectArray\n   */\n  constructor(objectArray) {\n    if (!Array.isArray(objectArray)) {\n      throw new Error('The input to objects-to-csv must be an array of objects.');\n    }\n\n    if (objectArray.length > 0) {\n      if (objectArray.some(row => typeof row !== 'object')) {\n        throw new Error('The array must contain objects, not other data types.');\n      }\n    }\n\n    this.data = objectArray;\n  }\n\n  /**\n   * Saves the CSV file to the specified file.\n   * @param {string} filename - The path and filename of the new CSV file.\n   * @param {object} options - The options for writing to disk.\n   * @param {boolean} [options.append] - Whether to append to file. Default is overwrite (false).\n   * @param {boolean} [options.bom] - Append the BOM mark so that Excel shows\n   * @param {boolean} [options.allColumns] - Whether to check all items for column names or only the first.  Default is the first.\n   * Unicode correctly.\n   */\n  async toDisk(filename, options) {\n    if (!filename) {\n      throw new Error('Empty filename when trying to write to disk.');\n    }\n\n    let addHeader = false;\n\n    // If the file didn't exist yet or is empty, add the column headers\n    // as the first line of the file. Do not add it when we are appending\n    // to an existing file.\n    const fileNotExists = !fs.existsSync(filename) || fs.statSync(filename).size === 0;\n    if (fileNotExists || !options || !options.append) {\n      addHeader = true;\n    }\n\n    const allColumns = options && options.allColumns\n      ? options.allColumns\n      : false;\n\n    let data = await this.toString(addHeader, allColumns);\n    // Append the BOM mark if requested at the beginning of the file, otherwise\n    // Excel won't show Unicode correctly. The actual BOM mark will be EF BB BF,\n    // see https://stackoverflow.com/a/27975629/6269864 for details.\n    if (options && options.bom && fileNotExists) {\n      data = '\\ufeff' + data;\n    }\n\n    if (options && options.append) {\n      return new Promise((resolve, reject) => {\n        fs.appendFile(filename, data, 'utf8', (error) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        fs.writeFile(filename, data, 'utf8', (error) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * Returns the CSV file as string.\n   * @param {boolean} header - If false, omit the first row containing the\n   * column names.\n   * @param {boolean} allColumns - Whether to check all items for column names.\n   *   Uses only the first item if false.\n   * @returns {Promise<string>}\n   */\n  async toString(header = true, allColumns = false) {\n    return await convert(this.data, header, allColumns);\n  }\n}\n\n/**\n * Private method to run the actual conversion of array of objects to CSV data.\n * @param {object[]} data\n * @param {boolean} header - Whether the first line should contain column headers.\n * @param {boolean} allColumns - Whether to check all items for column names.\n *   Uses only the first item if false.\n * @returns {string}\n */\nasync function convert(data, header = true, allColumns = false) {\n  if (data.length === 0) {\n    return '';\n  }\n\n  const columnNames =\n    allColumns\n      ? [...data\n        .reduce((columns, row) => { // check each object to compile a full list of column names\n          Object.keys(row).map(rowKey => columns.add(rowKey));\n          return columns;\n        }, new Set())]\n      : Object.keys(data[0]); // just figure out columns from the first item in array\n\n  if (allColumns) {\n    columnNames.sort(); // for predictable order of columns\n  }\n\n  // This will hold data in the format that `async-csv` can accept, i.e.\n  // an array of arrays.\n  let csvInput = [];\n  if (header) {\n    csvInput.push(columnNames);\n  }\n\n  // Add all other rows:\n  csvInput.push(\n    ...data.map(row => columnNames.map(column => row[column])),\n  );\n\n  return await csv.stringify(csvInput);\n}\n\nmodule.exports = ObjectsToCsv;\n"]},"metadata":{},"sourceType":"script"}