{"ast":null,"code":"var _assertThisInitialized = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _wrapNativeSuper = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _slicedToArray = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/usr/local/lib/node_modules/react-scripts/node_modules/@babel/runtime/helpers/createSuper\");\n\n/*\nCSV Stringify\n\nPlease look at the [project documentation](https://csv.js.org/stringify/) for\nadditional information.\n*/\nvar _require = require('stream'),\n    Transform = _require.Transform;\n\nvar bom_utf8 = Buffer.from([239, 187, 191]);\n\nvar Stringifier = /*#__PURE__*/function (_Transform) {\n  \"use strict\";\n\n  _inherits(Stringifier, _Transform);\n\n  var _super = _createSuper(Stringifier);\n\n  function Stringifier() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Stringifier);\n\n    _this = _super.call(this, _objectSpread(_objectSpread({}, {\n      writableObjectMode: true\n    }), opts));\n    var options = {};\n    var err; // Merge with user options\n\n    for (var opt in opts) {\n      options[underscore(opt)] = opts[opt];\n    }\n\n    if (err = _this.normalize(options)) throw err;\n\n    switch (options.record_delimiter) {\n      case 'auto':\n        options.record_delimiter = null;\n        break;\n\n      case 'unix':\n        options.record_delimiter = \"\\n\";\n        break;\n\n      case 'mac':\n        options.record_delimiter = \"\\r\";\n        break;\n\n      case 'windows':\n        options.record_delimiter = \"\\r\\n\";\n        break;\n\n      case 'ascii':\n        options.record_delimiter = \"\\x1E\";\n        break;\n\n      case 'unicode':\n        options.record_delimiter = \"\\u2028\";\n        break;\n    } // Expose options\n\n\n    _this.options = options; // Internal state\n\n    _this.state = {\n      stop: false\n    }; // Information\n\n    _this.info = {\n      records: 0\n    };\n    return _this;\n  }\n\n  _createClass(Stringifier, [{\n    key: \"normalize\",\n    value: function normalize(options) {\n      // Normalize option `bom`\n      if (options.bom === undefined || options.bom === null || options.bom === false) {\n        options.bom = false;\n      } else if (options.bom !== true) {\n        return new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', ['option `bom` is optional and must be a boolean value,', \"got \".concat(JSON.stringify(options.bom))]);\n      } // Normalize option `delimiter`\n\n\n      if (options.delimiter === undefined || options.delimiter === null) {\n        options.delimiter = ',';\n      } else if (Buffer.isBuffer(options.delimiter)) {\n        options.delimiter = options.delimiter.toString();\n      } else if (typeof options.delimiter !== 'string') {\n        return new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', ['option `delimiter` must be a buffer or a string,', \"got \".concat(JSON.stringify(options.delimiter))]);\n      } // Normalize option `quote`\n\n\n      if (options.quote === undefined || options.quote === null) {\n        options.quote = '\"';\n      } else if (options.quote === true) {\n        options.quote = '\"';\n      } else if (options.quote === false) {\n        options.quote = '';\n      } else if (Buffer.isBuffer(options.quote)) {\n        options.quote = options.quote.toString();\n      } else if (typeof options.quote !== 'string') {\n        return new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', ['option `quote` must be a boolean, a buffer or a string,', \"got \".concat(JSON.stringify(options.quote))]);\n      } // Normalize option `quoted`\n\n\n      if (options.quoted === undefined || options.quoted === null) {\n        options.quoted = false;\n      } else {// todo\n      } // Normalize option `quoted_empty`\n\n\n      if (options.quoted_empty === undefined || options.quoted_empty === null) {\n        options.quoted_empty = undefined;\n      } else {// todo\n      } // Normalize option `quoted_match`\n\n\n      if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {\n        options.quoted_match = null;\n      } else if (!Array.isArray(options.quoted_match)) {\n        options.quoted_match = [options.quoted_match];\n      }\n\n      if (options.quoted_match) {\n        var _iterator = _createForOfIteratorHelper(options.quoted_match),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var quoted_match = _step.value;\n            var isString = typeof quoted_match === 'string';\n            var isRegExp = quoted_match instanceof RegExp;\n\n            if (!isString && !isRegExp) {\n              return Error(\"Invalid Option: quoted_match must be a string or a regex, got \".concat(JSON.stringify(quoted_match)));\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } // Normalize option `quoted_string`\n\n\n      if (options.quoted_string === undefined || options.quoted_string === null) {\n        options.quoted_string = false;\n      } else {// todo\n      } // Normalize option `eof`\n\n\n      if (options.eof === undefined || options.eof === null) {\n        options.eof = true;\n      } else {// todo\n      } // Normalize option `escape`\n\n\n      if (options.escape === undefined || options.escape === null) {\n        options.escape = '\"';\n      } else if (Buffer.isBuffer(options.escape)) {\n        options.escape = options.escape.toString();\n      } else if (typeof options.escape !== 'string') {\n        return Error(\"Invalid Option: escape must be a buffer or a string, got \".concat(JSON.stringify(options.escape)));\n      }\n\n      if (options.escape.length > 1) {\n        return Error(\"Invalid Option: escape must be one character, got \".concat(options.escape.length, \" characters\"));\n      } // Normalize option `header`\n\n\n      if (options.header === undefined || options.header === null) {\n        options.header = false;\n      } else {// todo\n      } // Normalize option `columns`\n\n\n      options.columns = this.normalize_columns(options.columns); // Normalize option `quoted`\n\n      if (options.quoted === undefined || options.quoted === null) {\n        options.quoted = false;\n      } else {// todo\n      } // Normalize option `cast`\n\n\n      if (options.cast === undefined || options.cast === null) {\n        options.cast = {};\n      } else {// todo\n      } // Normalize option cast.bigint\n\n\n      if (options.cast.bigint === undefined || options.cast.bigint === null) {\n        // Cast boolean to string by default\n        options.cast.bigint = function (value) {\n          return '' + value;\n        };\n      } // Normalize option cast.boolean\n\n\n      if (options.cast.boolean === undefined || options.cast.boolean === null) {\n        // Cast boolean to string by default\n        options.cast.boolean = function (value) {\n          return value ? '1' : '';\n        };\n      } // Normalize option cast.date\n\n\n      if (options.cast.date === undefined || options.cast.date === null) {\n        // Cast date to timestamp string by default\n        options.cast.date = function (value) {\n          return '' + value.getTime();\n        };\n      } // Normalize option cast.number\n\n\n      if (options.cast.number === undefined || options.cast.number === null) {\n        // Cast number to string using native casting by default\n        options.cast.number = function (value) {\n          return '' + value;\n        };\n      } // Normalize option cast.object\n\n\n      if (options.cast.object === undefined || options.cast.object === null) {\n        // Stringify object as JSON by default\n        options.cast.object = function (value) {\n          return JSON.stringify(value);\n        };\n      } // Normalize option cast.string\n\n\n      if (options.cast.string === undefined || options.cast.string === null) {\n        // Leave string untouched\n        options.cast.string = function (value) {\n          return value;\n        };\n      } // Normalize option `record_delimiter`\n\n\n      if (options.record_delimiter === undefined || options.record_delimiter === null) {\n        options.record_delimiter = '\\n';\n      } else if (Buffer.isBuffer(options.record_delimiter)) {\n        options.record_delimiter = options.record_delimiter.toString();\n      } else if (typeof options.record_delimiter !== 'string') {\n        return Error(\"Invalid Option: record_delimiter must be a buffer or a string, got \".concat(JSON.stringify(options.record_delimiter)));\n      }\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      if (this.state.stop === true) {\n        return;\n      } // Chunk validation\n\n\n      if (!Array.isArray(chunk) && typeof chunk !== 'object') {\n        this.state.stop = true;\n        return callback(Error(\"Invalid Record: expect an array or an object, got \".concat(JSON.stringify(chunk))));\n      } // Detect columns from the first record\n\n\n      if (this.info.records === 0) {\n        if (Array.isArray(chunk)) {\n          if (this.options.header === true && !this.options.columns) {\n            this.state.stop = true;\n            return callback(Error('Undiscoverable Columns: header option requires column option or object records'));\n          }\n        } else if (this.options.columns === undefined || this.options.columns === null) {\n          this.options.columns = this.normalize_columns(Object.keys(chunk));\n        }\n      } // Emit the header\n\n\n      if (this.info.records === 0) {\n        this.bom();\n        this.headers();\n      } // Emit and stringify the record if an object or an array\n\n\n      try {\n        this.emit('record', chunk, this.info.records);\n      } catch (err) {\n        this.state.stop = true;\n        return this.emit('error', err);\n      } // Convert the record into a string\n\n\n      var chunk_string;\n\n      if (this.options.eof) {\n        chunk_string = this.stringify(chunk);\n\n        if (chunk_string === undefined) {\n          return;\n        } else {\n          chunk_string = chunk_string + this.options.record_delimiter;\n        }\n      } else {\n        chunk_string = this.stringify(chunk);\n\n        if (chunk_string === undefined) {\n          return;\n        } else {\n          if (this.options.header || this.info.records) {\n            chunk_string = this.options.record_delimiter + chunk_string;\n          }\n        }\n      } // Emit the csv\n\n\n      this.info.records++;\n      this.push(chunk_string);\n      callback();\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      if (this.info.records === 0) {\n        this.bom();\n        this.headers();\n      }\n\n      callback();\n    }\n  }, {\n    key: \"stringify\",\n    value: function stringify(chunk) {\n      var _this2 = this;\n\n      var chunkIsHeader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (typeof chunk !== 'object') {\n        return chunk;\n      }\n\n      var _this$options = this.options,\n          columns = _this$options.columns,\n          header = _this$options.header;\n      var record = []; // Record is an array\n\n      if (Array.isArray(chunk)) {\n        // We are getting an array but the user has specified output columns. In\n        // this case, we respect the columns indexes\n        if (columns) {\n          chunk.splice(columns.length);\n        } // Cast record elements\n\n\n        for (var _i = 0; _i < chunk.length; _i++) {\n          var field = chunk[_i];\n\n          var _this$__cast = this.__cast(field, {\n            index: _i,\n            column: _i,\n            records: this.info.records,\n            header: chunkIsHeader\n          }),\n              _this$__cast2 = _slicedToArray(_this$__cast, 2),\n              err = _this$__cast2[0],\n              value = _this$__cast2[1];\n\n          if (err) {\n            this.emit('error', err);\n            return;\n          }\n\n          record[_i] = [value, field];\n        } // Record is a literal object\n\n      } else {\n        if (columns) {\n          for (var _i2 = 0; _i2 < columns.length; _i2++) {\n            var _field = get(chunk, columns[_i2].key);\n\n            var _this$__cast3 = this.__cast(_field, {\n              index: _i2,\n              column: columns[_i2].key,\n              records: this.info.records,\n              header: chunkIsHeader\n            }),\n                _this$__cast4 = _slicedToArray(_this$__cast3, 2),\n                _err = _this$__cast4[0],\n                _value = _this$__cast4[1];\n\n            if (_err) {\n              this.emit('error', _err);\n              return;\n            }\n\n            record[_i2] = [_value, _field];\n          }\n        } else {\n          var _iterator2 = _createForOfIteratorHelper(chunk),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var column = _step2.value;\n              var _field2 = chunk[column];\n\n              var _this$__cast5 = this.__cast(_field2, {\n                index: i,\n                column: columns[i].key,\n                records: this.info.records,\n                header: chunkIsHeader\n              }),\n                  _this$__cast6 = _slicedToArray(_this$__cast5, 2),\n                  _err2 = _this$__cast6[0],\n                  _value2 = _this$__cast6[1];\n\n              if (_err2) {\n                this.emit('error', _err2);\n                return;\n              }\n\n              record.push([_value2, _field2]);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      }\n\n      var csvrecord = '';\n\n      var _loop = function _loop(_i3) {\n        var options = void 0,\n            err = void 0;\n\n        var _record$_i = _slicedToArray(record[_i3], 2),\n            value = _record$_i[0],\n            field = _record$_i[1];\n\n        if (typeof value === \"string\") {\n          options = _this2.options;\n        } else if (isObject(value)) {\n          // let { value, ...options } = value\n          options = value;\n          value = options.value;\n          delete options.value;\n\n          if (typeof value !== \"string\" && value !== undefined && value !== null) {\n            _this2.emit(\"error\", Error(\"Invalid Casting Value: returned value must return a string, null or undefined, got \".concat(JSON.stringify(value))));\n\n            return {\n              v: void 0\n            };\n          }\n\n          options = _objectSpread(_objectSpread({}, _this2.options), options);\n\n          if (err = _this2.normalize(options)) {\n            _this2.emit(\"error\", err);\n\n            return {\n              v: void 0\n            };\n          }\n        } else if (value === undefined || value === null) {\n          options = _this2.options;\n        } else {\n          _this2.emit(\"error\", Error(\"Invalid Casting Value: returned value must return a string, an object, null or undefined, got \".concat(JSON.stringify(value))));\n\n          return {\n            v: void 0\n          };\n        }\n\n        var _options = options,\n            delimiter = _options.delimiter,\n            escape = _options.escape,\n            quote = _options.quote,\n            quoted = _options.quoted,\n            quoted_empty = _options.quoted_empty,\n            quoted_string = _options.quoted_string,\n            quoted_match = _options.quoted_match,\n            record_delimiter = _options.record_delimiter;\n\n        if (value) {\n          if (typeof value !== 'string') {\n            _this2.emit(\"error\", Error(\"Formatter must return a string, null or undefined, got \".concat(JSON.stringify(value))));\n\n            return {\n              v: null\n            };\n          }\n\n          var containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;\n          var containsQuote = quote !== '' && value.indexOf(quote) >= 0;\n          var containsEscape = value.indexOf(escape) >= 0 && escape !== quote;\n          var containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n          var quotedString = quoted_string && typeof field === 'string';\n          var quotedMatch = quoted_match && quoted_match.filter(function (quoted_match) {\n            if (typeof quoted_match === 'string') {\n              return value.indexOf(quoted_match) !== -1;\n            } else {\n              return quoted_match.test(value);\n            }\n          });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          var shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;\n\n          if (shouldQuote === true && containsEscape === true) {\n            var regexp = escape === '\\\\' ? new RegExp(escape + escape, 'g') : new RegExp(escape, 'g');\n            value = value.replace(regexp, escape + escape);\n          }\n\n          if (containsQuote === true) {\n            var _regexp = new RegExp(quote, 'g');\n\n            value = value.replace(_regexp, escape + quote);\n          }\n\n          if (shouldQuote === true) {\n            value = quote + value + quote;\n          }\n\n          csvrecord += value;\n        } else if (quoted_empty === true || field === '' && quoted_string === true && quoted_empty !== false) {\n          csvrecord += quote + quote;\n        }\n\n        if (_i3 !== record.length - 1) {\n          csvrecord += delimiter;\n        }\n      };\n\n      for (var _i3 = 0; _i3 < record.length; _i3++) {\n        var _ret = _loop(_i3);\n\n        if (typeof _ret === \"object\") return _ret.v;\n      }\n\n      return csvrecord;\n    }\n  }, {\n    key: \"bom\",\n    value: function bom() {\n      if (this.options.bom !== true) {\n        return;\n      }\n\n      this.push(bom_utf8);\n    }\n  }, {\n    key: \"headers\",\n    value: function headers() {\n      if (this.options.header === false) {\n        return;\n      }\n\n      if (this.options.columns === undefined) {\n        return;\n      }\n\n      var headers = this.options.columns.map(function (column) {\n        return column.header;\n      });\n\n      if (this.options.eof) {\n        headers = this.stringify(headers, true) + this.options.record_delimiter;\n      } else {\n        headers = this.stringify(headers);\n      }\n\n      this.push(headers);\n    }\n  }, {\n    key: \"__cast\",\n    value: function __cast(value, context) {\n      var type = typeof value;\n\n      try {\n        if (type === 'string') {\n          // Fine for 99% of the cases\n          return [undefined, this.options.cast.string(value, context)];\n        } else if (type === 'bigint') {\n          return [undefined, this.options.cast.bigint(value, context)];\n        } else if (type === 'number') {\n          return [undefined, this.options.cast.number(value, context)];\n        } else if (type === 'boolean') {\n          return [undefined, this.options.cast.boolean(value, context)];\n        } else if (value instanceof Date) {\n          return [undefined, this.options.cast.date(value, context)];\n        } else if (type === 'object' && value !== null) {\n          return [undefined, this.options.cast.object(value, context)];\n        } else {\n          return [undefined, value, value];\n        }\n      } catch (err) {\n        return [err];\n      }\n    }\n  }, {\n    key: \"normalize_columns\",\n    value: function normalize_columns(columns) {\n      if (columns === undefined || columns === null) {\n        return undefined;\n      }\n\n      if (typeof columns !== 'object') {\n        throw Error('Invalid option \"columns\": expect an array or an object');\n      }\n\n      if (!Array.isArray(columns)) {\n        var newcolumns = [];\n\n        for (var k in columns) {\n          newcolumns.push({\n            key: k,\n            header: columns[k]\n          });\n        }\n\n        columns = newcolumns;\n      } else {\n        var _newcolumns = [];\n\n        var _iterator3 = _createForOfIteratorHelper(columns),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var column = _step3.value;\n\n            if (typeof column === 'string') {\n              _newcolumns.push({\n                key: column,\n                header: column\n              });\n            } else if (typeof column === 'object' && column !== undefined && !Array.isArray(column)) {\n              if (!column.key) {\n                throw Error('Invalid column definition: property \"key\" is required');\n              }\n\n              if (column.header === undefined) {\n                column.header = column.key;\n              }\n\n              _newcolumns.push(column);\n            } else {\n              throw Error('Invalid column definition: expect a string or an object');\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        columns = _newcolumns;\n      }\n\n      return columns;\n    }\n  }]);\n\n  return Stringifier;\n}(Transform);\n\nvar stringify = function stringify() {\n  var data, options, callback;\n\n  for (var _i4 in arguments) {\n    var argument = arguments[_i4];\n    var type = typeof argument;\n\n    if (data === undefined && Array.isArray(argument)) {\n      data = argument;\n    } else if (options === undefined && isObject(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === 'function') {\n      callback = argument;\n    } else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', \"got \".concat(JSON.stringify(argument), \" at index \").concat(_i4)]);\n    }\n  }\n\n  var stringifier = new Stringifier(options);\n\n  if (callback) {\n    var chunks = [];\n    stringifier.on('readable', function () {\n      var chunk;\n\n      while ((chunk = this.read()) !== null) {\n        chunks.push(chunk);\n      }\n    });\n    stringifier.on('error', function (err) {\n      callback(err);\n    });\n    stringifier.on('end', function () {\n      callback(undefined, chunks.join(''));\n    });\n  }\n\n  if (data !== undefined) {\n    // Give a chance for events to be registered later\n    if (typeof setImmediate === 'function') {\n      setImmediate(function () {\n        var _iterator4 = _createForOfIteratorHelper(data),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var record = _step4.value;\n            stringifier.write(record);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        stringifier.end();\n      });\n    } else {\n      var _iterator5 = _createForOfIteratorHelper(data),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var record = _step5.value;\n          stringifier.write(record);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      stringifier.end();\n    }\n  }\n\n  return stringifier;\n};\n\nvar CsvError = /*#__PURE__*/function (_Error) {\n  \"use strict\";\n\n  _inherits(CsvError, _Error);\n\n  var _super2 = _createSuper(CsvError);\n\n  function CsvError(code, message) {\n    var _this3;\n\n    _classCallCheck(this, CsvError);\n\n    if (Array.isArray(message)) message = message.join(' ');\n    _this3 = _super2.call(this, message);\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(_assertThisInitialized(_this3), CsvError);\n    }\n\n    _this3.code = code;\n\n    for (var _len = arguments.length, contexts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      contexts[_key - 2] = arguments[_key];\n    }\n\n    for (var _i5 = 0, _contexts = contexts; _i5 < _contexts.length; _i5++) {\n      var context = _contexts[_i5];\n\n      for (var key in context) {\n        var value = context[key];\n        _this3[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n\n    return _this3;\n  }\n\n  return CsvError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nstringify.Stringifier = Stringifier;\nstringify.CsvError = CsvError;\nmodule.exports = stringify;\n\nvar isObject = function isObject(obj) {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n};\n\nvar underscore = function underscore(str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return '_' + match.toLowerCase();\n  });\n}; // Lodash implementation of `get`\n\n\nvar charCodeOfDot = '.'.charCodeAt(0);\nvar reEscapeChar = /\\\\(\\\\)?/g;\nvar rePropName = RegExp( // Match anything that isn't a dot or bracket.\n'[^.[\\\\]]+' + '|' + // Or match property names within brackets.\n'\\\\[(?:' + // Match a non-string expression.\n'([^\"\\'][^[]*)' + '|' + // Or match strings (supports escaping characters).\n'([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' + ')\\\\]' + '|' + // Or match \"\" as the space between consecutive dots or empty brackets.\n'(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))', 'g');\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nvar reIsPlainProp = /^\\w*$/;\n\nvar getTag = function getTag(value) {\n  if (!value) value === undefined ? '[object Undefined]' : '[object Null]';\n  return Object.prototype.toString.call(value);\n};\n\nvar isKey = function isKey(value, object) {\n  if (Array.isArray(value)) {\n    return false;\n  }\n\n  var type = typeof value;\n\n  if (type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)) {\n    return true;\n  }\n\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n};\n\nvar isSymbol = function isSymbol(value) {\n  var type = typeof value;\n  return type === 'symbol' || type === 'object' && value && getTag(value) === '[object Symbol]';\n};\n\nvar stringToPath = function stringToPath(string) {\n  var result = [];\n\n  if (string.charCodeAt(0) === charCodeOfDot) {\n    result.push('');\n  }\n\n  string.replace(rePropName, function (match, expression, quote, subString) {\n    var key = match;\n\n    if (quote) {\n      key = subString.replace(reEscapeChar, '$1');\n    } else if (expression) {\n      key = expression.trim();\n    }\n\n    result.push(key);\n  });\n  return result;\n};\n\nvar castPath = function castPath(value, object) {\n  if (Array.isArray(value)) {\n    return value;\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value);\n  }\n};\n\nvar toKey = function toKey(value) {\n  if (typeof value === 'string' || isSymbol(value)) return value;\n  var result = \"\".concat(value);\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n};\n\nvar get = function get(object, path) {\n  path = castPath(path, object);\n  var index = 0;\n  var length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n\n  return index && index === length ? object : undefined;\n};","map":{"version":3,"sources":["/Users/angelvazquez/Dropbox/My Mac (Angels-MacBook-Pro-4.local)/Documents/Projects/Murmuration - 10:04:2021/node_modules/csv-stringify/lib/index.js"],"names":["require","Transform","bom_utf8","Buffer","from","Stringifier","opts","writableObjectMode","options","err","opt","underscore","normalize","record_delimiter","state","stop","info","records","bom","undefined","CsvError","JSON","stringify","delimiter","isBuffer","toString","quote","quoted","quoted_empty","quoted_match","Array","isArray","isString","isRegExp","RegExp","Error","quoted_string","eof","escape","length","header","columns","normalize_columns","cast","bigint","value","boolean","date","getTime","number","object","string","chunk","encoding","callback","Object","keys","headers","emit","chunk_string","push","chunkIsHeader","record","splice","i","field","__cast","index","column","get","key","csvrecord","isObject","containsdelimiter","indexOf","containsQuote","containsEscape","containsRecordDelimiter","quotedString","quotedMatch","filter","test","shouldQuote","regexp","replace","map","context","type","Date","newcolumns","k","data","arguments","argument","stringifier","chunks","on","read","join","setImmediate","write","end","code","message","captureStackTrace","contexts","parse","module","exports","obj","str","_","match","toLowerCase","charCodeOfDot","charCodeAt","reEscapeChar","rePropName","reIsDeepProp","reIsPlainProp","getTag","prototype","call","isKey","isSymbol","stringToPath","result","expression","subString","trim","castPath","toKey","INFINITY","path"],"mappings":"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","sourcesContent":["\n/*\nCSV Stringify\n\nPlease look at the [project documentation](https://csv.js.org/stringify/) for\nadditional information.\n*/\n\nconst { Transform } = require('stream')\nconst bom_utf8 = Buffer.from([239, 187, 191])\n\nclass Stringifier extends Transform {\n  constructor(opts = {}){\n    super({...{writableObjectMode: true}, ...opts})\n    const options = {}\n    let err\n    // Merge with user options\n    for(let opt in opts){\n      options[underscore(opt)] = opts[opt]\n    }\n    if(err = this.normalize(options)) throw err\n    switch(options.record_delimiter){\n      case 'auto':\n        options.record_delimiter = null\n        break\n      case 'unix':\n        options.record_delimiter = \"\\n\"\n        break\n      case 'mac':\n        options.record_delimiter = \"\\r\"\n        break\n      case 'windows':\n        options.record_delimiter = \"\\r\\n\"\n        break\n      case 'ascii':\n        options.record_delimiter = \"\\u001e\"\n        break\n      case 'unicode':\n        options.record_delimiter = \"\\u2028\"\n        break\n    }\n    // Expose options\n    this.options = options\n    // Internal state\n    this.state = {\n      stop: false\n    }\n    // Information\n    this.info = {\n      records: 0\n    }\n  }\n  normalize(options){\n    // Normalize option `bom`\n    if(options.bom === undefined || options.bom === null || options.bom === false){\n      options.bom = false\n    }else if(options.bom !== true){\n      return new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', [\n        'option `bom` is optional and must be a boolean value,',\n        `got ${JSON.stringify(options.bom)}`\n      ])\n    }\n    // Normalize option `delimiter`\n    if(options.delimiter === undefined || options.delimiter === null){\n      options.delimiter = ','\n    }else if(Buffer.isBuffer(options.delimiter)){\n      options.delimiter = options.delimiter.toString()\n    }else if(typeof options.delimiter !== 'string'){\n      return new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', [\n        'option `delimiter` must be a buffer or a string,',\n        `got ${JSON.stringify(options.delimiter)}`\n      ])\n    }\n    // Normalize option `quote`\n    if(options.quote === undefined || options.quote === null){\n      options.quote = '\"'\n    }else if(options.quote === true){\n      options.quote = '\"'\n    }else if(options.quote === false){\n      options.quote = ''\n    }else if (Buffer.isBuffer(options.quote)){\n      options.quote = options.quote.toString()\n    }else if(typeof options.quote !== 'string'){\n      return new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', [\n        'option `quote` must be a boolean, a buffer or a string,',\n        `got ${JSON.stringify(options.quote)}`\n      ])\n    }\n    // Normalize option `quoted`\n    if(options.quoted === undefined || options.quoted === null){\n      options.quoted = false\n    }else{\n      // todo\n    }\n    // Normalize option `quoted_empty`\n    if(options.quoted_empty === undefined || options.quoted_empty === null){\n      options.quoted_empty = undefined\n    }else{\n      // todo\n    }\n    // Normalize option `quoted_match`\n    if(options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false){\n      options.quoted_match = null\n    }else if(!Array.isArray(options.quoted_match)){\n      options.quoted_match = [options.quoted_match]\n    }\n    if(options.quoted_match){\n      for(let quoted_match of options.quoted_match){\n        const isString = typeof quoted_match === 'string'\n        const isRegExp = quoted_match instanceof RegExp\n        if(!isString && !isRegExp){\n          return Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)\n        }\n      }\n    }\n    // Normalize option `quoted_string`\n    if(options.quoted_string === undefined || options.quoted_string === null){\n      options.quoted_string = false\n    }else{\n      // todo\n    }\n    // Normalize option `eof`\n    if(options.eof === undefined || options.eof === null){\n      options.eof = true\n    }else{\n      // todo\n    }\n    // Normalize option `escape`\n    if(options.escape === undefined || options.escape === null){\n      options.escape = '\"'\n    }else if(Buffer.isBuffer(options.escape)){\n      options.escape = options.escape.toString()\n    }else if(typeof options.escape !== 'string'){\n      return Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)\n    }\n    if (options.escape.length > 1){\n      return Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)\n    }\n    // Normalize option `header`\n    if(options.header === undefined || options.header === null){\n      options.header = false\n    }else{\n      // todo\n    }\n    // Normalize option `columns`\n    options.columns = this.normalize_columns(options.columns)\n    // Normalize option `quoted`\n    if(options.quoted === undefined || options.quoted === null){\n      options.quoted = false\n    }else{\n      // todo\n    }\n    // Normalize option `cast`\n    if(options.cast === undefined || options.cast === null){\n      options.cast = {}\n    }else{\n      // todo\n    }\n    // Normalize option cast.bigint\n    if(options.cast.bigint === undefined || options.cast.bigint === null){\n      // Cast boolean to string by default\n      options.cast.bigint = value => '' + value\n    }\n    // Normalize option cast.boolean\n    if(options.cast.boolean === undefined || options.cast.boolean === null){\n      // Cast boolean to string by default\n      options.cast.boolean = value => value ? '1' : ''\n    }\n    // Normalize option cast.date\n    if(options.cast.date === undefined || options.cast.date === null){\n      // Cast date to timestamp string by default\n      options.cast.date = value => '' + value.getTime()\n    }\n    // Normalize option cast.number\n    if(options.cast.number === undefined || options.cast.number === null){\n      // Cast number to string using native casting by default\n      options.cast.number = value => '' + value\n    }\n    // Normalize option cast.object\n    if(options.cast.object === undefined || options.cast.object === null){\n      // Stringify object as JSON by default\n      options.cast.object = value => JSON.stringify(value)\n    }\n    // Normalize option cast.string\n    if(options.cast.string === undefined || options.cast.string === null){\n      // Leave string untouched\n      options.cast.string = function(value){return value}\n    }\n    // Normalize option `record_delimiter`\n    if(options.record_delimiter === undefined || options.record_delimiter === null){\n      options.record_delimiter = '\\n'\n    }else if(Buffer.isBuffer(options.record_delimiter)){\n      options.record_delimiter = options.record_delimiter.toString()\n    }else if(typeof options.record_delimiter !== 'string'){\n      return Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)\n    }\n  }\n  _transform(chunk, encoding, callback){\n    if(this.state.stop === true){\n      return\n    }\n    // Chunk validation\n    if(!Array.isArray(chunk) && typeof chunk !== 'object'){\n      this.state.stop = true\n      return callback(Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`))\n    }\n    // Detect columns from the first record\n    if(this.info.records === 0){\n      if(Array.isArray(chunk)){\n        if(this.options.header === true && !this.options.columns){\n          this.state.stop = true\n          return callback(Error('Undiscoverable Columns: header option requires column option or object records'))\n        }\n      }else if(this.options.columns === undefined || this.options.columns === null){\n        this.options.columns = this.normalize_columns(Object.keys(chunk))\n      }\n    }\n    // Emit the header\n    if(this.info.records === 0){\n      this.bom()\n      this.headers()\n    }\n    // Emit and stringify the record if an object or an array\n    try{\n      this.emit('record', chunk, this.info.records)\n    }catch(err){\n      this.state.stop = true\n      return this.emit('error', err)\n    }\n    // Convert the record into a string\n    let chunk_string\n    if(this.options.eof){\n      chunk_string = this.stringify(chunk)\n      if(chunk_string === undefined){\n        return\n      }else{\n        chunk_string = chunk_string + this.options.record_delimiter\n      }\n    }else{\n      chunk_string = this.stringify(chunk)\n      if(chunk_string === undefined){\n        return\n      }else{\n        if(this.options.header || this.info.records){\n          chunk_string = this.options.record_delimiter + chunk_string\n        }\n      }\n    }\n    // Emit the csv\n    this.info.records++\n    this.push(chunk_string)\n    callback()\n  }\n  _flush(callback){\n    if(this.info.records === 0){\n      this.bom()\n      this.headers()\n    }\n    callback()\n  }\n  stringify(chunk, chunkIsHeader=false){\n    if(typeof chunk !== 'object'){\n      return chunk\n    }\n    const {columns, header} = this.options\n    const record = []\n    // Record is an array\n    if(Array.isArray(chunk)){\n      // We are getting an array but the user has specified output columns. In\n      // this case, we respect the columns indexes\n      if(columns){\n        chunk.splice(columns.length)\n      }\n      // Cast record elements\n      for(let i=0; i<chunk.length; i++){\n        const field = chunk[i]\n        const [err, value] = this.__cast(field, {\n          index: i, column: i, records: this.info.records, header: chunkIsHeader\n        })\n        if(err){\n          this.emit('error', err)\n          return\n        }\n        record[i] = [value, field]\n      }\n    // Record is a literal object\n    }else{\n      if(columns){\n        for(let i=0; i<columns.length; i++){\n          const field = get(chunk, columns[i].key)\n          const [err, value] = this.__cast(field, {\n            index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader\n          })\n          if(err){\n            this.emit('error', err)\n            return\n          }\n          record[i] = [value, field]\n        }\n      }else{\n        for(let column of chunk){\n          const field = chunk[column]\n          const [err, value] = this.__cast(field, {\n            index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader\n          })\n          if(err){\n            this.emit('error', err)\n            return\n          }\n          record.push([value, field])\n        }\n      }\n    }\n    let csvrecord = ''\n    for(let i=0; i<record.length; i++){\n      let options, err\n      let [value, field] = record[i]\n      if(typeof value === \"string\"){\n        options = this.options\n      }else if(isObject(value)){\n        // let { value, ...options } = value\n        options = value\n        value = options.value\n        delete options.value\n        if(typeof value !== \"string\" && value !== undefined && value !== null){\n          this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`))\n          return\n        }\n        options = {...this.options, ...options}\n        if(err = this.normalize(options)){\n          this.emit(\"error\", err)\n          return\n        }\n      }else if(value === undefined || value === null){\n        options = this.options\n      }else{\n        this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`))\n        return\n      }\n      const {delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter} = options\n      if(value){\n        if(typeof value !== 'string'){\n          this.emit(\"error\", Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`))\n          return null\n        }\n        const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0\n        const containsQuote = (quote !== '') && value.indexOf(quote) >= 0\n        const containsEscape = value.indexOf(escape) >= 0 && (escape !== quote)\n        const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0\n        const quotedString = quoted_string && typeof field === 'string'\n        let quotedMatch = quoted_match && quoted_match.filter( quoted_match => {\n          if(typeof quoted_match === 'string'){\n            return value.indexOf(quoted_match) !== -1\n          }else{\n            return quoted_match.test(value)\n          }\n        })\n        quotedMatch = quotedMatch && quotedMatch.length > 0\n        const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch\n        if(shouldQuote === true && containsEscape === true){\n          const regexp = escape === '\\\\'\n          ? new RegExp(escape + escape, 'g')\n          : new RegExp(escape, 'g')\n          value = value.replace(regexp, escape + escape)\n        }\n        if(containsQuote === true){\n          const regexp = new RegExp(quote,'g')\n          value = value.replace(regexp, escape + quote)\n        }\n        if(shouldQuote === true){\n          value = quote + value + quote\n        }\n        csvrecord += value\n      }else if(quoted_empty === true || (field === '' && quoted_string === true && quoted_empty !== false)){\n        csvrecord += quote + quote\n      }\n      if(i !== record.length - 1){\n        csvrecord += delimiter\n      }\n    }\n    return csvrecord\n  }\n  bom(){\n    if(this.options.bom !== true){\n      return\n    }\n    this.push(bom_utf8)\n  }\n  headers(){\n    if(this.options.header === false){\n      return\n    }\n    if(this.options.columns === undefined){\n      return\n    }\n    let headers = this.options.columns.map(column => column.header)\n    if(this.options.eof){\n      headers = this.stringify(headers, true) + this.options.record_delimiter\n    }else{\n      headers = this.stringify(headers)\n    }\n    this.push(headers)\n  }\n  __cast(value, context){\n    const type = typeof value\n    try{\n      if(type === 'string'){ // Fine for 99% of the cases\n        return [undefined, this.options.cast.string(value, context)]\n      }else if(type === 'bigint'){\n        return [undefined, this.options.cast.bigint(value, context)]\n      }else if(type === 'number'){\n        return [undefined, this.options.cast.number(value, context)]\n      }else if(type === 'boolean'){\n        return [undefined, this.options.cast.boolean(value, context)]\n      }else if(value instanceof Date){\n        return [undefined, this.options.cast.date(value, context)]\n      }else if(type === 'object' && value !== null){\n        return [undefined, this.options.cast.object(value, context)]\n      }else{\n        return [undefined, value, value]\n      }\n    }catch(err){\n      return [err]\n    }\n  }\n  normalize_columns(columns){\n    if(columns === undefined || columns === null){\n      return undefined\n    }\n    if(typeof columns !== 'object'){\n      throw Error('Invalid option \"columns\": expect an array or an object')\n    }\n    if(!Array.isArray(columns)){\n      const newcolumns = []\n      for(let k in columns){\n        newcolumns.push({\n          key: k,\n          header: columns[k]\n        })\n      }\n      columns = newcolumns\n    }else{\n      const newcolumns = []\n      for(let column of columns){\n        if(typeof column === 'string'){\n          newcolumns.push({\n            key: column,\n            header: column\n          })\n        }else if(typeof column === 'object' && column !== undefined && !Array.isArray(column)){\n          if(!column.key){\n            throw Error('Invalid column definition: property \"key\" is required')\n          }\n          if(column.header === undefined){\n            column.header = column.key\n          }\n          newcolumns.push(column)\n        }else{\n          throw Error('Invalid column definition: expect a string or an object')\n        }\n      }\n      columns = newcolumns\n    }\n    return columns\n  }\n}\n\nconst stringify = function(){\n  let data, options, callback\n  for(let i in arguments){\n    const argument = arguments[i]\n    const type = typeof argument\n    if(data === undefined && (Array.isArray(argument))){\n      data = argument\n    }else if(options === undefined && isObject(argument)){\n      options = argument\n    }else if(callback === undefined && type === 'function'){\n      callback = argument\n    }else{\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ])\n    }\n  }\n  const stringifier = new Stringifier(options)\n  if(callback){\n    const chunks = []\n    stringifier.on('readable', function(){\n      let chunk\n      while((chunk = this.read()) !== null){\n        chunks.push(chunk)\n      }\n    })\n    stringifier.on('error', function(err){\n      callback(err)\n    })\n    stringifier.on('end', function(){\n      callback(undefined, chunks.join(''))\n    })\n  }\n  if(data !== undefined){\n    // Give a chance for events to be registered later\n    if(typeof setImmediate === 'function'){\n      setImmediate(function(){\n        for(let record of data){\n          stringifier.write(record)\n        }\n        stringifier.end()\n      })\n    }else{\n      for(let record of data){\n        stringifier.write(record)\n      }\n      stringifier.end()\n    }\n  }\n  return stringifier\n}\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ')\n    super(message)\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError)\n    }\n    this.code = code\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key]\n        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value))\n      }\n    }\n  }\n}\n\nstringify.Stringifier = Stringifier\n\nstringify.CsvError = CsvError\n\nmodule.exports = stringify\n\nconst isObject = function(obj){\n  return typeof obj === 'object' && obj !== null && ! Array.isArray(obj)\n}\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase()\n  })\n}\n\n// Lodash implementation of `get`\n\nconst charCodeOfDot = '.'.charCodeAt(0)\nconst reEscapeChar = /\\\\(\\\\)?/g\nconst rePropName = RegExp(\n  // Match anything that isn't a dot or bracket.\n  '[^.[\\\\]]+' + '|' +\n  // Or match property names within brackets.\n  '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' + '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n  ')\\\\]'+ '|' +\n  // Or match \"\" as the space between consecutive dots or empty brackets.\n  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n, 'g')\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/\nconst reIsPlainProp = /^\\w*$/\nconst getTag = function(value){\n  if(!value)\n    value === undefined ? '[object Undefined]' : '[object Null]'\n  return Object.prototype.toString.call(value)\n}\nconst isKey = function(value, object){\n  if(Array.isArray(value)){\n    return false\n  }\n  const type = typeof value\n  if(type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)){\n    return true\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object))\n}\nconst isSymbol = function(value){\n  const type = typeof value\n  return type === 'symbol' || (type === 'object' && value && getTag(value) === '[object Symbol]')\n}\nconst stringToPath = function(string){\n  const result = []\n  if(string.charCodeAt(0) === charCodeOfDot){\n    result.push('')\n  }\n  string.replace(rePropName, function(match, expression, quote, subString){\n    let key = match\n    if(quote){\n      key = subString.replace(reEscapeChar, '$1')\n    }else if(expression){\n      key = expression.trim()\n    }\n    result.push(key)\n  })\n  return result\n}\nconst castPath = function(value, object){\n  if(Array.isArray(value)){\n    return value\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value)\n  }\n}\nconst toKey = function(value){\n  if(typeof value === 'string' || isSymbol(value))\n    return value\n  const result = `${value}`\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result\n}\nconst get = function(object, path){\n  path = castPath(path, object)\n  let index = 0\n  const length = path.length\n  while(object != null && index < length){\n    object = object[toKey(path[index++])]\n  }\n  return (index && index === length) ? object : undefined\n}\n"]},"metadata":{},"sourceType":"script"}