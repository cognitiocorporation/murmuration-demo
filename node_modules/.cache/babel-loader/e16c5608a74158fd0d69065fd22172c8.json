{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/angelvazquez/Desktop/murmuration-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/angelvazquez/Desktop/murmuration-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/angelvazquez/Desktop/murmuration-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/angelvazquez/Desktop/murmuration-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/angelvazquez/Desktop/murmuration-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar csv = require('async-csv');\n\nvar fs = require('fs');\n/**\n * Converts an array of objects into a CSV file.\n */\n\n\nvar ObjectsToCsv = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of the object array to csv converter.\n   * @param {object[]} objectArray\n   */\n  function ObjectsToCsv(objectArray) {\n    _classCallCheck(this, ObjectsToCsv);\n\n    if (!Array.isArray(objectArray)) {\n      throw new Error('The input to objects-to-csv must be an array of objects.');\n    }\n\n    if (objectArray.length > 0) {\n      if (objectArray.some(function (row) {\n        return typeof row !== 'object';\n      })) {\n        throw new Error('The array must contain objects, not other data types.');\n      }\n    }\n\n    this.data = objectArray;\n  }\n  /**\n   * Saves the CSV file to the specified file.\n   * @param {string} filename - The path and filename of the new CSV file.\n   * @param {object} options - The options for writing to disk.\n   * @param {boolean} [options.append] - Whether to append to file. Default is overwrite (false).\n   * @param {boolean} [options.bom] - Append the BOM mark so that Excel shows\n   * @param {boolean} [options.allColumns] - Whether to check all items for column names or only the first.  Default is the first.\n   * Unicode correctly.\n   */\n\n\n  _createClass(ObjectsToCsv, [{\n    key: \"toDisk\",\n    value: function () {\n      var _toDisk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(filename, options) {\n        var addHeader, fileNotExists, allColumns, data;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (filename) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('Empty filename when trying to write to disk.');\n\n              case 2:\n                addHeader = false; // If the file didn't exist yet or is empty, add the column headers\n                // as the first line of the file. Do not add it when we are appending\n                // to an existing file.\n\n                fileNotExists = !fs.existsSync(filename) || fs.statSync(filename).size === 0;\n\n                if (fileNotExists || !options || !options.append) {\n                  addHeader = true;\n                }\n\n                allColumns = options && options.allColumns ? options.allColumns : false;\n                _context.next = 8;\n                return this.toString(addHeader, allColumns);\n\n              case 8:\n                data = _context.sent;\n\n                // Append the BOM mark if requested at the beginning of the file, otherwise\n                // Excel won't show Unicode correctly. The actual BOM mark will be EF BB BF,\n                // see https://stackoverflow.com/a/27975629/6269864 for details.\n                if (options && options.bom && fileNotExists) {\n                  data = \"\\uFEFF\" + data;\n                }\n\n                if (!(options && options.append)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  fs.appendFile(filename, data, 'utf8', function (error) {\n                    if (error) {\n                      reject(error);\n                    } else {\n                      resolve(data);\n                    }\n                  });\n                }));\n\n              case 14:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  fs.writeFile(filename, data, 'utf8', function (error) {\n                    if (error) {\n                      reject(error);\n                    } else {\n                      resolve(data);\n                    }\n                  });\n                }));\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function toDisk(_x, _x2) {\n        return _toDisk.apply(this, arguments);\n      }\n\n      return toDisk;\n    }()\n    /**\n     * Returns the CSV file as string.\n     * @param {boolean} header - If false, omit the first row containing the\n     * column names.\n     * @param {boolean} allColumns - Whether to check all items for column names.\n     *   Uses only the first item if false.\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function () {\n      var _toString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var header,\n            allColumns,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                header = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : true;\n                allColumns = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;\n                _context2.next = 4;\n                return convert(this.data, header, allColumns);\n\n              case 4:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function toString() {\n        return _toString.apply(this, arguments);\n      }\n\n      return toString;\n    }()\n  }]);\n\n  return ObjectsToCsv;\n}();\n/**\n * Private method to run the actual conversion of array of objects to CSV data.\n * @param {object[]} data\n * @param {boolean} header - Whether the first line should contain column headers.\n * @param {boolean} allColumns - Whether to check all items for column names.\n *   Uses only the first item if false.\n * @returns {string}\n */\n\n\nfunction convert(_x3) {\n  return _convert.apply(this, arguments);\n}\n\nfunction _convert() {\n  _convert = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(data) {\n    var header,\n        allColumns,\n        columnNames,\n        csvInput,\n        _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            header = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : true;\n            allColumns = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : false;\n\n            if (!(data.length === 0)) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", '');\n\n          case 4:\n            columnNames = allColumns ? _toConsumableArray(data.reduce(function (columns, row) {\n              // check each object to compile a full list of column names\n              Object.keys(row).map(function (rowKey) {\n                return columns.add(rowKey);\n              });\n              return columns;\n            }, new Set())) : Object.keys(data[0]); // just figure out columns from the first item in array\n\n            if (allColumns) {\n              columnNames.sort(); // for predictable order of columns\n            } // This will hold data in the format that `async-csv` can accept, i.e.\n            // an array of arrays.\n\n\n            csvInput = [];\n\n            if (header) {\n              csvInput.push(columnNames);\n            } // Add all other rows:\n\n\n            csvInput.push.apply(csvInput, _toConsumableArray(data.map(function (row) {\n              return columnNames.map(function (column) {\n                return row[column];\n              });\n            })));\n            _context3.next = 11;\n            return csv.stringify(csvInput);\n\n          case 11:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _convert.apply(this, arguments);\n}\n\nmodule.exports = ObjectsToCsv;","map":null,"metadata":{},"sourceType":"script"}